Language: None
- [LangGraph Platform](../../concepts/langgraph_platform.md)
- [LangGraph Server](../../concepts/langgraph_server.md)
- [`useStream()` React Hook](./use_stream_react.md)

---

Language: tsx title="src/agent/ui.tsx"
const WeatherComponent = (props: { city: string }) => {
  return <div>Weather for {props.city}</div>;
};

export default {
  weather: WeatherComponent,
};

---

Language: json
{
  "node_version": "20",
  "graphs": {
    "agent": "./src/agent/index.ts:graph"
  },
  "ui": {
    "agent": "./src/agent/ui.tsx"
  }
}

---

Language: None
```tsx
import "./styles.css";

---

Language: None
const WeatherComponent = (props: { city: string }) => {
  return <div className="bg-red-500">Weather for {props.city}</div>;
};

---

Language: None
export default {
  weather: WeatherComponent,
};
```

---

Language: None
```css
@import "tailwindcss";
```

---

Language: None
```python title="src/agent.py"
import uuid
from typing import Annotated, Sequence, TypedDict

---

Language: None
from langchain_core.messages import AIMessage, BaseMessage
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph
from langgraph.graph.message import add_messages
from langgraph.graph.ui import AnyUIMessage, ui_message_reducer, push_ui_message

---

Language: None
class AgentState(TypedDict):  # noqa: D101
    messages: Annotated[Sequence[BaseMessage], add_messages]
    ui: Annotated[Sequence[AnyUIMessage], ui_message_reducer]

---

Language: None
async def weather(state: AgentState):
    class WeatherOutput(TypedDict):
        city: str

---

Language: None
    weather: WeatherOutput = (
        await ChatOpenAI(model="gpt-4o-mini")
        .with_structured_output(WeatherOutput)
        .with_config({"tags": ["nostream"]})
        .ainvoke(state["messages"])
    )

---

Language: None
    message = AIMessage(
        id=str(uuid.uuid4()),
        content=f"Here's the weather for {weather['city']}",
    )

---

Language: None
    # Emit UI elements associated with the message
    push_ui_message("weather", weather, message=message)
    return {"messages": [message]}

---

Language: None
workflow = StateGraph(AgentState)
workflow.add_node(weather)
workflow.add_edge("__start__", "weather")
graph = workflow.compile()
```

---

Language: None
Use the `typedUi` utility to emit UI elements from your agent nodes:

---

Language: None
```typescript title="src/agent/index.ts"
import {
  typedUi,
  uiMessageReducer,
} from "@langchain/langgraph-sdk/react-ui/server";

---

Language: None
import { ChatOpenAI } from "@langchain/openai";
import { v4 as uuidv4 } from "uuid";
import { z } from "zod";

---

Language: None
import type ComponentMap from "./ui.js";

---

Language: None
import {
  Annotation,
  MessagesAnnotation,
  StateGraph,
  type LangGraphRunnableConfig,
} from "@langchain/langgraph";

---

Language: None
const AgentState = Annotation.Root({
  ...MessagesAnnotation.spec,
  ui: Annotation({ reducer: uiMessageReducer, default: () => [] }),
});

---

Language: None
export const graph = new StateGraph(AgentState)
  .addNode("weather", async (state, config) => {
    // Provide the type of the component map to ensure
    // type safety of `ui.push()` calls as well as
    // pushing the messages to the `ui` and sending a custom event as well.
    const ui = typedUi<typeof ComponentMap>(config);

---

Language: None
    const weather = await new ChatOpenAI({ model: "gpt-4o-mini" })
      .withStructuredOutput(z.object({ city: z.string() }))
      .withConfig({ tags: ["nostream"] })
      .invoke(state.messages);

---

Language: None
    const response = {
      id: uuidv4(),
      type: "ai",
      content: `Here's the weather for ${weather.city}`,
    };

---

Language: None
    // Emit UI elements associated with the AI message
    ui.push({ name: "weather", props: weather }, { message: response });

---

Language: None
    return { messages: [response] };
  })
  .addEdge("__start__", "weather")
  .compile();
```

---

Language: tsx title="src/app/page.tsx"
"use client";

import { useStream } from "@langchain/langgraph-sdk/react";
import { LoadExternalComponent } from "@langchain/langgraph-sdk/react-ui";

export default function Page() {
  const { thread, values } = useStream({
    apiUrl: "http://localhost:2024",
    assistantId: "agent",
  });

  return (
    <div>
      {thread.messages.map((message) => (
        <div key={message.id}>
          {message.content}
          {values.ui
            ?.filter((ui) => ui.metadata?.message_id === message.id)
            .map((ui) => (
              <LoadExternalComponent key={ui.id} stream={thread} message={ui} />
            ))}
        </div>
      ))}
    </div>
  );
}

---

Language: tsx
const clientComponents = {
  weather: WeatherComponent,
};

<LoadExternalComponent
  stream={thread}
  message={ui}
  components={clientComponents}
/>;

---

Language: tsx
<LoadExternalComponent
  stream={thread}
  message={ui}
  fallback={<div>Loading...</div>}
/>

---

Language: None
```tsx
<LoadExternalComponent
  stream={thread}
  message={ui}
  namespace="custom-namespace"
/>
```

---

Language: None
```json
{
  "ui": {
    "custom-namespace": "./src/agent/ui.tsx"
  }
}
```

---

Language: tsx
import { useStreamContext } from "@langchain/langgraph-sdk/react-ui";

const WeatherComponent = (props: { city: string }) => {
  const { thread, submit } = useStreamContext();
  return (
    <>
      <div>Weather for {props.city}</div>

      <button
        onClick={() => {
          const newMessage = {
            type: "human",
            content: `What's the weather in ${props.city}?`,
          };

          submit({ messages: [newMessage] });
        }}
      >
        Retry
      </button>
    </>
  );
};

---

Language: tsx
<LoadExternalComponent stream={thread} message={ui} meta={{ userId: "123" }} />

---

Language: tsx
import { useStreamContext } from "@langchain/langgraph-sdk/react-ui";

const WeatherComponent = (props: { city: string }) => {
  const { meta } = useStreamContext<
    { city: string },
    { MetaType: { userId?: string } }
  >();

  return (
    <div>
      Weather for {props.city} (user: {meta?.userId})
    </div>
  );
};

---

Language: tsx
import { uiMessageReducer } from "@langchain/langgraph-sdk/react-ui";

const { thread, submit } = useStream({
  apiUrl: "http://localhost:2024",
  assistantId: "agent",
  onCustomEvent: (event, options) => {
    options.mutate((prev) => {
      const ui = uiMessageReducer(prev.ui ?? [], event);
      return { ...prev, ui };
    });
  },
});

---

Language: None
```python
from typing import Annotated, Sequence, TypedDict

---

Language: None
from langchain_anthropic import ChatAnthropic
from langchain_core.messages import AIMessage, AIMessageChunk, BaseMessage
from langgraph.graph import StateGraph
from langgraph.graph.message import add_messages
from langgraph.graph.ui import AnyUIMessage, push_ui_message, ui_message_reducer

---

Language: None
class AgentState(TypedDict):  # noqa: D101
    messages: Annotated[Sequence[BaseMessage], add_messages]
    ui: Annotated[Sequence[AnyUIMessage], ui_message_reducer]

---

Language: None
class CreateTextDocument(TypedDict):
    """Prepare a document heading for the user."""

---

Language: None
    title: str

---

Language: None
async def writer_node(state: AgentState):
    model = ChatAnthropic(model="claude-3-5-sonnet-latest")
    message: AIMessage = await model.bind_tools(
        tools=[CreateTextDocument],
        tool_choice={"type": "tool", "name": "CreateTextDocument"},
    ).ainvoke(state["messages"])

---

Language: None
    tool_call = next(
        (x["args"] for x in message.tool_calls if x["name"] == "CreateTextDocument"),
        None,
    )

---

Language: None
    if tool_call:
        ui_message = push_ui_message("writer", tool_call, message=message)
        ui_message_id = ui_message["id"]

---

Language: None
        # We're already streaming the LLM response to the client through UI messages
        # so we don't need to stream it again to the `messages` stream mode.
        content_stream = model.with_config({"tags": ["nostream"]}).astream(
            f"Create a document with the title: {tool_call['title']}"
        )

---

Language: None
        content: AIMessageChunk | None = None
        async for chunk in content_stream:
            content = content + chunk if content else chunk

---

Language: None
            push_ui_message(
                "writer",
                {"content": content.text()},
                id=ui_message_id,
                message=message,
                # Use `merge=rue` to merge props with the existing UI message
                merge=True,
            )

---

Language: None
    return {"messages": [message]}
```

---

Language: None
```tsx
import {
  Annotation,
  MessagesAnnotation,
  type LangGraphRunnableConfig,
} from "@langchain/langgraph";
import { z } from "zod";
import { ChatAnthropic } from "@langchain/anthropic";
import {
  typedUi,
  uiMessageReducer,
} from "@langchain/langgraph-sdk/react-ui/server";
import type { AIMessageChunk } from "@langchain/core/messages";

---

Language: None
import type ComponentMap from "./ui";

---

Language: None
const AgentState = Annotation.Root({
  ...MessagesAnnotation.spec,
  ui: Annotation({ reducer: uiMessageReducer, default: () => [] }),
});

---

Language: None
async function writerNode(
  state: typeof AgentState.State,
  config: LangGraphRunnableConfig
): Promise<typeof AgentState.Update> {
  const ui = typedUi<typeof ComponentMap>(config);

---

Language: None
  const model = new ChatAnthropic({ model: "claude-3-5-sonnet-latest" });
  const message = await model
    .bindTools(
      [
        {
          name: "create_text_document",
          description: "Prepare a document heading for the user.",
          schema: z.object({ title: z.string() }),
        },
      ],
      { tool_choice: { type: "tool", name: "create_text_document" } }
    )
    .invoke(state.messages);

---

Language: None
  type ToolCall = { name: "create_text_document"; args: { title: string } };
  const toolCall = message.tool_calls?.find(
    (tool): tool is ToolCall => tool.name === "create_text_document"
  );

---

Language: None
  if (toolCall) {
    const { id, name } = ui.push(
      { name: "writer", props: { title: toolCall.args.title } },
      { message }
    );

---

Language: None
    const contentStream = await model
      // We're already streaming the LLM response to the client through UI messages
      // so we don't need to stream it again to the `messages` stream mode.
      .withConfig({ tags: ["nostream"] })
      .stream(`Create a short poem with the topic: ${message.text}`);

---

Language: None
    let content: AIMessageChunk | undefined;
    for await (const chunk of contentStream) {
      content = content?.concat(chunk) ?? chunk;

---

Language: None
      ui.push(
        { id, name, props: { content: content?.text } },
        // Use `merge: true` to merge props with the existing UI message
        { message, merge: true }
      );
    }
  }

---

Language: None
  return { messages: [message] };
}
```

---

Language: None
```tsx
function WriterComponent(props: { title: string; content?: string }) {
  return (
    <article>
      <h2>{props.title}</h2>
      <p style={{ whiteSpace: "pre-wrap" }}>{props.content}</p>
    </article>
  );
}

---

Language: None
export default {
  weather: WriterComponent,
};
```

---

Language: None
```python
from langgraph.graph.ui import push_ui_message, delete_ui_message

---

Language: None
# push message
message = push_ui_message("weather", {"city": "London"})

---

Language: None
# remove said message
delete_ui_message(message["id"])
```

---

Language: None
```tsx
// push message
const message = ui.push({ name: "weather", props: { city: "London" } });

---

Language: None
// remove said message
ui.delete(message.id);
```

---

